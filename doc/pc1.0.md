# PC 端 v1.0 — MVP 版本工作细化

> 对应 [pc.md](./pc.md) 第七章 v1.0 版本规划，供开发与排期使用。

## 一、版本目标

- **目标**：完成核心功能闭环，可供内测使用。
- **范围**：邮箱注册/登录、笔记本与文件夹管理、Markdown 编辑器（所见即所得）、基础待办事项、图片压缩工具。
- **架构**：前端仅与本地 Go 后端通信；需访问服务端时（如登录、注册）由 Go 转发并返回结果。

---

## 二、邮箱注册/登录

### 2.1 Go 后端

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 服务端代理接口 | 提供本地 API（如 `POST /api/auth/register`、`POST /api/auth/login`），由 Go 转发到远程服务端（邮箱+验证码注册、邮箱+密码/验证码登录），并将响应原样或规范化后返回前端 |
| 2 | 登录态管理 | 接收并存储服务端返回的 token（如内存或本地加密存储），后续请求需访问服务端时自动在请求头携带 token |
| 3 | 登出与 token 失效 | 提供 `POST /api/auth/logout`，清除本地 token；识别 401 等未授权响应并通知前端跳转登录 |
| 4 | 错误与超时处理 | 统一处理网络错误、超时、服务端错误码，返回前端可用的错误信息与状态码 |

### 2.2 前端

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 登录/注册页 | 登录（邮箱+密码、邮箱+验证码）、注册（邮箱+验证码+设置密码）、忘记密码入口；所有请求只调用本地 Go 接口 |
| 2 | 登录态与路由守卫 | 根据 Go 返回的登录结果或独立接口（如 `GET /api/auth/me`）判断是否已登录；未登录时跳转登录页，禁止进入主界面 |
| 3 | 主界面登出 | 提供登出入口，调用 Go 登出接口后清空前端状态并跳转登录页 |

### 2.3 验收要点

- 能通过邮箱+验证码完成注册、通过邮箱+密码或验证码登录。
- 未登录无法进入主功能；登出后需重新登录。
- 前端不直接请求远程服务端，仅请求本地 Go。

---

## 三、笔记本与文件夹管理

### 3.1 数据与存储（Go）

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 本地 SQLite 设计 | 建表：笔记本（id、名称、排序、创建/更新时间）、文件夹（id、笔记本 id、父文件夹 id、名称、排序、创建/更新时间）、笔记（id、所属笔记本/文件夹、标题、内容、创建/更新时间等） |
| 2 | 笔记本 CRUD API | `GET/POST/PUT/DELETE /api/notebooks`：列表、创建、重命名、删除（软删或硬删，与「回收站」策略一致） |
| 3 | 文件夹 CRUD API | `GET/POST/PUT/DELETE /api/notebooks/:id/folders` 或统一 ` /api/folders`，支持层级（父文件夹 id）；列表需支持按层级/排序返回 |
| 4 | 默认笔记本 | 首次使用时若无可用的笔记本，可自动创建一个默认笔记本，或由前端在空状态时引导创建 |

### 3.2 前端

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 侧边栏-笔记本列表 | 展示笔记本列表；支持新建、重命名、删除；删除前二次确认 |
| 2 | 侧边栏-文件夹树 | 在选中笔记本下展示文件夹树；支持新建、重命名、删除、拖拽排序/移动（可选 v1.0 最小为平铺或单层文件夹） |
| 3 | 空状态 | 无笔记本时引导用户创建第一个笔记本 |
| 4 | 与笔记联动 | 当前选中的笔记本/文件夹作为创建笔记时的默认归属，并在笔记列表中过滤（见第四节） |
实现目录：D:\go\src\life_journey\front\pc

### 3.3 验收要点

- 可创建、重命名、删除笔记本；可创建、重命名、删除文件夹（层级按 v1.0 约定实现）。
- 侧边栏展示与操作流畅；新建笔记时能正确归属到当前选中的笔记本/文件夹。

---

## 四、Markdown 编辑器（所见即所得）

### 4.1 Go 后端

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 笔记 CRUD API | `GET/POST/PUT/DELETE /api/notes`：列表（支持按笔记本 id、文件夹 id 过滤、分页）、创建、更新、删除；删除可进回收站（更新状态或挪到回收站表） |
| 2 | 笔记内容存储 | 笔记正文以 Markdown 或 HTML 存于 SQLite（与前端编辑器约定一致）；列表接口可只返回标题、摘要、更新时间等，详情接口返回全文 |
| 3 | 搜索（可选 v1.0 最小） | `GET /api/notes/search?q=关键词`：本地 SQL 模糊查询标题与正文，返回匹配笔记列表 |
实现目录：D:\go\src\life_journey\server\client

### 4.2 前端编辑方案选型与开源参考

#### 4.2.1 可选方案对比

| 方案 | 技术栈 | 特点 | 适用场景 |
|------|--------|------|----------|
| **Tiptap** | 基于 ProseMirror，Vue/React 组件 | 模块化、扩展丰富、社区活跃；需自行维护 Markdown ↔ 文档模型转换 | 需要强定制、多扩展的 WYSIWYG |
| **Milkdown** | 基于 ProseMirror，Markdown 优先 | 原生 Markdown 编辑与渲染，插件体系清晰 | 以 Markdown 为单一数据源的笔记 |
| **Vditor** | 自研编辑器 | 三模式（所见即所得/即时渲染/分屏）、开箱中文友好、体积较大 | 快速落地、对 Markdown 三模式有需求 |
| **思源/Lute** | 思源内核 Go + [Lute](https://github.com/88250/lute) 引擎 | 块级编辑、双向链接、与 Go 内核同栈；需对接思源数据格式或仅借鉴解析层 | 深度借鉴思源交互与块模型时 |

v1.0 建议在 **Milkdown** 或 **Vditor** 中选型：Milkdown 更轻、与 CommonMark 生态易对齐；Vditor 上手快、功能集中。若后续要做块级引用、双向链接，可参考思源的数据结构（块、ID、引用关系）再扩展。

#### 4.2.2 思源开源方案借鉴（[siyuan-note/siyuan](https://github.com/siyuan-note/siyuan)）

思源为「TypeScript 前端 + Go 内核」的隐私优先知识管理软件，与当前 PC 端架构（前端 + Go 本地后端）一致，可重点借鉴以下部分：

| 借鉴点 | 说明 |
|--------|------|
| **编辑器引擎 Lute** | [88250/lute](https://github.com/88250/lute) 为 Go 实现的 Markdown 解析/渲染引擎，思源内核用其做服务端解析与导出。本项目中若需在 **Go 端** 做 Markdown 转 HTML、摘要提取、搜索高亮等，可引入 Lute 或参考其实现，与前端「所见即所得」编辑器的渲染结果保持一致。 |
| **块级（Block）模型** | 思源以块为最小单位存储（标题、段落、列表项等各有块 ID），支持块级引用与双向链接。v1.0 可不实现块级，仅做「整篇笔记」存储；若后续做块引用，可参考思源 `*.sy` 的 JSON 结构与块 ID 设计。 |
| **Markdown WYSIWYG 交互** | 思源为块式编辑：每段/标题/列表为一块，支持块菜单、拖拽、折叠。v1.0 可先做传统「整页 WYSIWYG」，后续再考虑块级交互与块菜单（如 Ctrl+/）。 |
| **内核与前端通信** | 思源通过本地 HTTP API（内核 Go 提供）与前端通信，与当前「前端只调 Go」的架构一致；可参考其 [API 文档](https://github.com/siyuan-note/siyuan/blob/master/API.md) 的接口划分与鉴权方式。 |

注意：思源整体为 AGPL-3.0，直接复用其前端或内核代码需遵守许可；仅借鉴架构思路、数据格式或使用独立开源的 Lute 引擎则不强制传染。

#### 4.2.3 CommonMark 规范与一致性（[commonmark/commonmark-spec](https://github.com/commonmark/commonmark-spec)）

[CommonMark](https://commonmark.org) 是 Markdown 的标准化规范，对 John Gruber 原始语法中未定义的部分做了明确约定，便于不同实现之间行为一致。

| 要点 | 说明 |
|------|------|
| **规范范围** | 涵盖段落、标题（ATX 与 Setext）、列表（有序/无序）、引用、代码块（围栏与缩进）、强调、链接、图片、行内代码、换行等；规范源文件为 [spec.txt](https://github.com/commonmark/commonmark-spec/blob/master/spec.txt)。 |
| **与原始 Markdown 的差异** | 例如：允许行末反斜杠换行、围栏代码块（` ``` ` / `~~~`）、有序列表可用 `)`、列表与引用等块级规则更明确。选型时优先选择声明支持 CommonMark 的编辑器，可减少「同一 Markdown 在不同平台表现不一致」的问题。 |
| **一致性测试** | 仓库内嵌 500+ 个规范测试用例，可用 [spec_tests.py](https://github.com/commonmark/commonmark-spec#running-tests-against-the-spec) 或 [commonmark-spec npm 包](https://www.npmjs.com/package/commonmark-spec) 的 `tests` 数组，对「Markdown → HTML」或「Markdown → 编辑器内部表示」做回归测试，保证解析与渲染符合规范。 |
| **v1.0 建议** | 存储与交换格式统一为 **CommonMark 子集**（至少：标题、加粗/斜体、列表、引用、围栏代码块、链接、图片）；编辑器选型时优先考虑支持 CommonMark 的实现；若有 Go 端解析（如摘要、搜索），建议与 CommonMark 行为对齐（可参考 [commonmark.js](https://github.com/commonmark/commonmark.js) 或 Lute）。 |

### 4.3 前端工作项（与 4.2 选型落地对应）

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 笔记列表区 | 展示当前笔记本/文件夹下的笔记列表；支持按时间排序；点击进入编辑 |
| 2 | 新建/删除笔记 | 新建笔记时默认归属当前选中笔记本/文件夹；删除笔记（调用 Go 接口，可进回收站） |
| 3 | 编辑器集成 | 在 4.2.1 选定方案（如 Milkdown/Vditor）上集成所见即所得；支持 CommonMark 常用语法：标题、加粗、斜体、列表、引用、围栏代码块、表格；支持快捷键（如 Ctrl+B/I 等） |
| 4 | 编辑与保存 | 编辑内容实时或防抖后调用 Go `PUT /api/notes/:id` 保存；新笔记先 `POST /api/notes` 再进入编辑；持久化格式与 4.2.3 约定一致（建议 Markdown/CommonMark） |
| 5 | 标题与文档信息 | 笔记标题可取自首行或单独字段；列表与详情处展示标题、修改时间等 |
| 6 | 一致性校验（可选） | 使用 CommonMark spec 的测试子集对编辑器「输入 Markdown → 输出/存储」做校验，避免与规范偏离 |

### 4.4 验收要点

- 在指定笔记本/文件夹下可新建、编辑、删除笔记；内容持久化到本地。
- 编辑器支持 CommonMark 常用语法与快捷键，编辑体验流畅；存储格式与 4.2.3 约定一致。
- 前端仅通过 Go 接口读写笔记，不直连服务端。

---

## 五、基础待办事项（创建、完成、删除）

### 5.1 Go 后端

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 待办表结构 | 建表：待办（id、标题、描述、状态：待办/进行中/已完成、创建/更新时间等）；v1.0 可不做优先级、截止时间、分类，仅做最小集合 |
| 2 | 待办 CRUD API | `GET/POST/PUT/DELETE /api/todos`：列表（可支持按状态筛选）、创建、更新（含状态变更）、删除 |
| 3 | 状态更新 | `PATCH /api/todos/:id` 或 `PUT` 支持只更新状态（如勾选完成） |

### 5.2 前端

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 待办列表视图 | 展示待办列表；支持按状态筛选（全部/未完成/已完成）；支持排序（如创建时间） |
| 2 | 新增待办 | 输入标题（必填）和可选描述，调用 Go 创建接口 |
| 3 | 完成/未完成 | 勾选切换完成状态，调用 Go 更新接口 |
| 4 | 删除待办 | 删除单条，调用 Go 删除接口；可选批量删除已完成 |

### 5.3 验收要点

- 可增删改待办，可勾选完成/未完成；列表与状态正确展示。
- 所有请求走 Go 本地 API。

---

## 六、图片压缩工具

### 6.1 Go 后端

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 压缩接口 | `POST /api/tools/image/compress`：接收上传的图片（单张或批量），按参数（如质量 1–100、最大宽高）压缩，返回压缩后文件或 URL（本地临时路径或 base64，由前端约定） |
| 2 | 依赖与实现 | 使用 Go 图片库（如 standard image、resize、jpeg options）实现缩放与质量压缩；支持常见格式（JPEG、PNG、WebP 等） |
| 3 | 安全与限制 | 限制单文件大小、分辨率、批量数量，防止滥用；临时文件及时清理 |

### 6.2 前端

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 工具入口 | 在侧边栏或顶部提供「工具」入口，进入后展示工具列表；v1.0 仅「图片压缩」 |
| 2 | 图片压缩页 | 支持选择/拖拽上传一张或多张图片；可选压缩质量（如滑块）；点击压缩后调用 Go 接口 |
| 3 | 结果展示与下载 | 展示压缩前后大小对比；提供压缩后图片预览与下载（根据 Go 返回方式：链接或 blob） |

### 6.3 验收要点

- 能上传图片并得到压缩结果；压缩后体积明显减小且可下载。
- 压缩逻辑在 Go 完成，前端只调接口与展示。

---

## 七、基础设施与联调（建议优先或并行）

| 序号 | 工作项 | 负责 | 说明 |
|-----|--------|------|------|
| 1 | 本地 Go 服务启动与端口 | Go | 应用启动时 Go 监听固定端口（如 13245），提供 `/api` 前缀的 REST API；CORS 允许前端源 |
| 2 | 前端请求基地址配置 | 前端 | 开发/打包环境统一请求 `http://127.0.0.1:端口/api`，不直连远程 |
| 3 | Electron 与 Go 进程 | Go + 前端 | Electron 主进程启动/拉起 Go 子进程，或由用户先启动 Go 再打开客户端；确保 Go 先于前端请求就绪 |
| 4 | 统一错误码与提示 | Go + 前端 | 约定错误响应格式（如 `{ code, message }`），前端统一提示网络错误或业务错误 |
| 5 | 日志与排查 | Go | 关键请求与错误打日志，便于排查登录失败、保存失败等问题 |

---

## 八、客户端全流程打包

### 8.1 打包整体流程

从源码到可分发安装包的全流程如下（建议用脚本或 CI 串联）：

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ 1. Go 后端   │ -> │ 2. 前端构建  │ -> │ 3. 放入资源  │ -> │ 4. Electron  │
│ 多平台编译   │    │ 静态资源产出  │    │ Go 二进制+   │    │ 打包/安装包   │
│             │    │ (npm build)  │    │ 前端产物     │    │ (installer)  │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
```

### 8.2 步骤一：Go 后端多平台编译

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 编译目标 | 与 Electron 目标一致：Windows(amd64/arm64)、macOS(amd64/arm64)、Linux(amd64/arm64)，按需裁剪 |
| 2 | 输出命名 | 建议统一命名便于 Electron 引用，如 `life-journey-server.exe`(Windows)、`life-journey-server`(macOS/Linux)；或按平台子目录放置如 `server/win32-x64/server.exe` |
| 3 | 构建命令示例 | `GOOS=windows GOARCH=amd64 go build -o dist/server/win32-x64/life-journey-server.exe ./cmd/server`（macOS/Linux 下交叉编译 Windows）；或使用 Makefile/脚本批量产出各平台二进制 |
| 4 | 关闭 CGO（可选） | 若 SQLite 使用 pure-go 驱动可关闭 CGO，便于跨平台；若用 CGO 需在对应平台或 Docker 内编译 |
| 5 | 版本与符号 | 编译时注入版本号（如 `-ldflags "-X main.Version=1.0.0"`），便于日志与关于页展示 |

### 8.3 步骤二：前端构建

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 构建命令 | 在客户端前端目录执行 `npm run build`（或 `pnpm build`），产出到固定目录（如 `dist` 或 `out`） |
| 2 | 环境变量 | 打包时使用生产环境（如 `NODE_ENV=production`），API 基地址指向本地（如 `VITE_API_BASE=http://127.0.0.1:13245`），不写死远程地址 |
| 3 | 输出内容 | 确保仅产出静态资源（HTML/JS/CSS/静态资源），供 Electron 加载；若有 public 资源一并复制到产出目录 |
| 4 | 与 Electron 约定 | Electron 主进程/electron-egg 配置的加载路径（如 `file://${__dirname}/../dist/index.html`）与该产出路径一致 |

### 8.4 步骤三：资源与目录结构

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | Go 二进制放置 | 将各平台 Go 二进制放入 Electron 的 **extraResources**（或 resources）目录，打包后位于应用安装目录的固定相对路径（如 `resources/server/win32-x64/life-journey-server.exe`），避免被打进 asar |
| 2 | 目录约定示例 | 打包前目录形如：`client/resources/win32-x64/life-journey-server.exe`、`client/resources/darwin-arm64/life-journey-server` 等；主进程通过 `process.resourcesPath` 或 `path.join(__dirname, '..', 'resources', platform, binaryName)` 获取可执行路径 |
| 3 | 前端产物位置 | 前端 build 产出放入 Electron 的静态加载路径（如 `client/dist`），或通过 electron-builder 的 `files` 包含进去 |
| 4 | 其他资源 | 图标、安装图、许可协议等按 electron-builder 文档放置（如 `build/icon.ico`、`build/installerIcon.ico`） |

### 8.5 步骤四：Electron 打包与安装包

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 打包工具 | 使用 electron-builder（或 electron-egg 内置的 builder 配置），在客户端根目录执行 `npm run dist`（或 `electron-builder`） |
| 2 | 配置 extraResources | 在 `electron-builder.yml` 或 `package.json` 的 `build` 中配置 `extraResources`：按平台复制对应 Go 二进制到 `resources/<platform>/`，确保主进程能按平台名（win32/darwin/linux）与 arch（x64/arm64）找到可执行文件 |
| 3 | 主进程启动 Go | 应用启动时（如 `app.whenReady` 后）由主进程 spawn 上述 Go 可执行路径；监听固定端口；退出时 kill 子进程；可增加健康检查（如轮询 `http://127.0.0.1:端口/health`）再加载窗口 |
| 4 | 安装包格式 | Windows：nsis 或 portable exe；macOS：dmg/pkg；Linux：AppImage 或 deb。按需在 electron-builder 中配置 target、artifactName 等 |
| 5 | 签名与公证（后续） | v1.0 可先不配置代码签名与 macOS 公证，内测分发；正式发布前再补充 Windows 签名与 Apple 公证，避免安装警告 |

### 8.6 版本与环境

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 统一版本号 | 应用版本号（如 1.0.0）在单处定义（如 `package.json` 的 version），Go 与 Electron 共用；打包时通过环境变量或构建参数传入 Go 的 `-ldflags` |
| 2 | 开发与打包区分 | 开发时：前端 dev server + 本地手动启动 Go 或由 Electron 在 dev 模式下启动 Go；打包后：仅通过主进程启动内嵌 Go，前端加载打包后的静态文件 |
| 3 | 日志与数据路径 | Go 在打包环境下将 SQLite、日志等写入用户数据目录（如 Electron 的 `app.getPath('userData')`），由主进程通过环境变量或启动参数传给 Go，避免写安装目录 |

### 8.7 脚本与 CI 建议

| 序号 | 工作项 | 说明 |
|-----|--------|------|
| 1 | 一键打包脚本 | 编写脚本（如 `scripts/build-all.sh` 或 `build-all.ps1`）：依次执行 Go 多平台编译 -> 前端 build -> 按平台复制 Go 二进制到 extraResources 目录 -> 执行 electron-builder；可选参数指定平台（win/darwin/linux） |
| 2 | 分平台打包 | 若 CI 为多机或矩阵构建，可每台机只编译当前 OS 的 Go 二进制 + 只打当前平台 Electron 包，减少单机依赖 |
| 3 | 产物命名 | 安装包命名含版本与平台，如 `LifeJourney-1.0.0-win-x64.exe`、`LifeJourney-1.0.0-mac-arm64.dmg`，便于内测分发与归档 |
| 4 | 清理 | 打包前清理上次的 `dist`、`out`、Go 输出目录，避免旧二进制被误打进包 |

### 8.8 验收要点（打包）

- 在目标系统上安装/解压后，能正常启动应用；主进程能拉起 Go，前端能访问本地 API。
- 关闭应用后 Go 进程一并退出，无残留进程。
- 用户数据（SQLite、配置等）写在用户目录，卸载后数据仍保留（或按产品策略可清理）。
- 安装包体积可控（Go 单二进制 + Electron 运行时 + 前端资源），可记录各平台体积作为基线。

---

## 九、v1.0 不包含（留待后续版本）

- 标签系统、回收站完整恢复流程、笔记搜索（若未在第四节实现）
- 待办优先级、截止时间、看板/日历视图
- PDF 合并/拆分、文件压缩解压、AI 相关功能
- 云端同步、多设备同步
- 暗色模式、插件系统

---

## 十、建议开发顺序

1. **基础设施**：Go 本地服务 + Electron 集成 + 前端基地址与 CORS。
2. **邮箱注册/登录**：Go 代理 + 前端登录/注册页 + 路由守卫。
3. **笔记本与文件夹**：SQLite 表与 Go CRUD + 前端侧边栏树形/列表。
4. **笔记与编辑器**：笔记 CRUD + 前端列表 + 所见即所得 Markdown 编辑器 + 保存联调。
5. **待办**：待办表与 Go CRUD + 前端列表与完成/删除。
6. **图片压缩**：Go 压缩接口 + 前端工具页与上传/下载。
7. **联调与内测**：全流程走通、错误场景与边界情况测试。
8. **全流程打包**：按第八章完成 Go 多平台编译、前端构建、Electron 打包与安装包产出；在目标系统上安装验证。
